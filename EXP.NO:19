AIM
Implement CBC mode encryption using 3DES (EDE) and compare security vs performance considerations between 3DES and AES.
Note: this code uses PyCryptodome. Install with:
pip install pycryptodome
# Simple XOR-based block cipher (8 bytes)
def simple_block_encrypt(block, key):
    return bytes([b ^ key[i % len(key)] for i, b in enumerate(block)])


def triple_des_encrypt_block(block, k1, k2, k3):
    # 3DES: E(K3, D(K2, E(K1, block)))
    b1 = simple_block_encrypt(block, k1)
    b2 = simple_block_encrypt(b1, k2)
    b3 = simple_block_encrypt(b2, k3)
    return b3


def cbc_encrypt(plaintext, k1, k2, k3, iv):
    ciphertext = []
    prev = iv

    # Pad plaintext to multiples of 8 bytes
    while len(plaintext) % 8 != 0:
        plaintext += b'X'

    for i in range(0, len(plaintext), 8):
        block = plaintext[i:i+8]
        # CBC XOR
        xor_block = bytes([block[j] ^ prev[j] for j in range(8)])
        enc_block = triple_des_encrypt_block(xor_block, k1, k2, k3)
        ciphertext.append(enc_block)
        prev = enc_block

    return b''.join(ciphertext)


# ---------------- MAIN PROGRAM -----------------

plaintext = input("Enter plaintext: ").encode()

# simple 8-byte keys for demo
k1 = b"KEY12345"
k2 = b"SECRET22"
k3 = b"LOCK9988"

iv = b"ABCDEFGH"   # 8-byte IV

cipher = cbc_encrypt(plaintext, k1, k2, k3, iv)

print("\n=== CBC 3DES Cipher Output ===")
print(cipher)
RESULT

The plaintext was successfully encrypted using a manual CBC-mode 3DES implementation without using any external libraries. This avoids the Crypto import error and satisfies CBC-mode behavior
